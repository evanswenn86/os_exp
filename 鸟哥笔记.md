# 鸟哥笔记
## 文件
下达『 ls -al 』列出所有的文件详细的权限与属性
第一个字符代表这个文件是『目录、文件或链接文件等等』：

    drwxr-x---   4    root   root     4096   Sep  8 14:06 .

当为[ d ]则是目录，例如上表档名为『.gconf』的那一行；  
当为[ - ]则是文件，例如上表档名为『install.log』那一行；  
若是[ l ]则表示为连结档(link file)；  
若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；  
若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。  

先将整个类型与权限数据分开查阅，并将十个字符整理成为如下所示：

    [-][rwx][r-x][r--]
     1  234  567  890
 1 为：代表这个文件名为目录或文件，本例中为文件(-)；

234为：拥有者的权限，本例中为可读、可写、可执行(rwx)；

567为：同群组用户权力，本例中为可读可执行(rx)；

890为：其他用户权力，本例中为可读(r)

第二栏表示有多少档名连结到此节点(i-node)：

第三栏表示这个文件(或目录)的『拥有者账号』

第四栏表示这个文件的所属群组

第五栏为这个文件的容量大小，默认单位为bytes；

第六栏为这个文件的建档日期或者是最近的修改日期：

第七栏为这个文件的档名

eg：

    -rw-r--r--  1 root     root          238 Jun 18 17:22 test.txt 
    #文件test.txt的拥有者为root，所属群组为root。
    #至于权限方面则只有root这个账号可以存取此文件，其他人则仅能读此文件；

### 改变权限：
+ chgrp ：改变文件所属群组
+ chown ：改变文件拥有者
+ chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性

改变所属群组, chgrp  
改变一个文件的群组真是很简单的，直接以chgrp来改变即可

    [root@www ~]# ls -l
    -rw-r--r--  1 root users 68495 Jun 25 08:53 install.log
    [root@www ~]# chgrp testing install.log
    chgrp: invalid group name `testing' <== 发生错误讯息啰～找不到这个群组名～

改变文件拥有者, chown

    范例：将install.log的拥有者改为bin这个账号：
    [root@www ~]# chown bin install.log
    [root@www ~]# ls -l
    -rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log

    范例：将install.log的拥有者与群组改回为root：
    [root@www ~]# chown root:root install.log
    [root@www ~]# ls -l
    -rw-r--r--  1 root root 68495 Jun 25 08:53 install.log

什么时候要使用chown或chgrp：

由于复制行为(cp)会复制执行者的属性与权限，所以！怎么办？.bashrc_test还是属于root所拥有， 如此一来，即使你将文件拿给bin这个使用者了，那他仍然无法修改的(看属性/权限就知道了吧)， 所以你就必须要将这个文件的拥有者与群组修改一下啰！知道如何修改了吧？

改变权限, chmod

文件权限的改变使用的是chmod这个指令，但是，权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。我们就来谈一谈：

数字类型改变文件权限

Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限， 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：
+ r:4
+ w:2
+ x:1
+ 
每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：
+ owner = rwx = 4+2+1 = 7
+ group = rwx = 4+2+1 = 7
+ others= --- = 0+0+0 = 0

所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：

    [root@www ~]# ls -al .bashrc
    -rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc
    [root@www ~]# chmod 777 .bashrc
    [root@www ~]# ls -al .bashrc
    -rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc

### 权限意义
+ r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；
+ w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)；
+ x (execute)：该文件具有可以被系统执行的权限。


我们的文件是否能被执行，则是藉由是否具有『x』这个权限来决定的！跟档名是没有绝对的关系的！

当你对一个文件具有w权限时，你可以具有写入/编辑/新增/修改文件的内容的权限， 但并不具备有删除该文件本身的权限！

### 文件系统配置
根据FHS(http://www.pathname.com/fhs/)的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准

进而开发出这四种交互形态以及相互作用：

可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；

不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。

不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；

可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。

#### 根目录
根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。

+ /bin	系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。
+ /boot	这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub这个开机管理程序， 则还会存在/boot/grub/这个目录喔！
+ /dev	在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/lp*, /dev/hd*, /dev/sd*等等
+ /etc	系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的文件有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等
+ /home	这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。
+ /lib	系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库， 以及在/bin或/sbin底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录， 因为该目录会放置核心相关的模块(驱动程序)喔！
+ /media	media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！
+ /mnt	如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 
+ /opt	这个是给第三方协力软件放置的目录。 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！
+ /root	系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。
+ /sbin	Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。
+ /srv	srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 
+ /tmp	这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！

#### /usr 目录的意义：

/usr里面放置的数据属于可分享的与不可变动的(shareable, static)  
很多读者都会误会/usr为user的缩写，其实usr是Unix Software Resource的缩写， 也就是『Unix操作系统软件资源』所放置的目录，而不是用户的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。/usr的次目录建议有底下这些：
+ /usr/X11R6/	为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。
+ /usr/bin/	绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处。(是否与开机过程有关)
+ /usr/include/	c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档喔！
+ /usr/lib/	包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生喔！
+ /usr/local/	系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！
+ /usr/sbin/	非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰！
+ /usr/share/	放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件
+ /usr/src/	一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。

#### /var 目录的意义：
如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 

因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：
+ /var/cache/	应用程序本身运作过程中会产生的一些暂存档；
+ /var/lib/	程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！
+ /var/lock/	某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。
+ /var/log/	重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。
+ /var/mail/	放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！
+ /var/run/	某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的。
+ /var/spool/	这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！

### 绝对与相对路径
除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意！因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：

+ 绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；
+ 相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法

而你必须要了解，相对路径是以『你当前所在路径的相对位置』来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？

    cd /var/log   (absolute)
    cd ../var/log (relative)
因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的！ 特别注意这两个特殊的目录：

+ .  ：代表当前的目录，也可以使用 ./ 来表示；
+ .. ：代表上一层目录，也可以 ../ 来代表。

## 目录
    cd 可以加这些目录符号
    .         代表此层目录
    ..        代表上一层目录
    -         代表前一个工作目录
    ~         代表『目前使用者身份』所在的家目录

### pwd命令：

    [root@www ~]# pwd [-P]
    选项与参数：
    -P  ：显示出确实的路径，而非使用连结 (link) 路径。

    范例：单纯显示出目前的工作目录：
    [root@www ~]# pwd
    /root   <== 显示出目录啦～

    范例：显示出实际的工作目录，而非连结档本身的目录名而已
    [root@www ~]# cd /var/mail   <==注意，/var/mail是一个连结档
    [root@www mail]# pwd
    /var/mail         <==列出目前的工作目录
    [root@www mail]# pwd -P
    /var/spool/mail   <==怎么回事？有没有加 -P 差很多～
    [root@www mail]# ls -ld /var/mail
    lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -> spool/mail
    # 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail 
    # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！

### mkdir命令：

    [root@www ~]# mkdir [-mp] 目录名称
    选项与参数：
    -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
    -p ：帮助你直接将所需要的目录(包含上一级目录)递回创建起来！

    [root@www tmp]# mkdir -p test1/test2/test3/test4
    # 加了这个 -p 的选项，可以自行帮你创建多层目录！

    [root@www tmp]# mkdir -m 711 test2
    [root@www tmp]# ls -l
    drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
    drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
    drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
    # 仔细看上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。

不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就会变的乱七八糟

### rmdir命令：

    [root@www ~]# rmdir [-p] 目录名称
    选项与参数：
    -p ：连同上一级『空的』目录也一起删除

    [root@www tmp]# rmdir -p test1/test2/test3/test4
    [root@www tmp]# ls -l        <==您看看，底下的输出中test与test1不见了！
    drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
    # 瞧！利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除～
    # 不过要注意的是，这个 rmdir 仅能『删除空的目录』喔！

### ls命令：

    [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
    [root@www ~]# ls [--color={never,auto,always}] 目录名称
    [root@www ~]# ls [--full-time] 目录名称
    选项与参数：
    -a  ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)
    -A  ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录
    -d  ：仅列出目录本身，而不是列出目录内的文件数据(常用)
    -f  ：直接列出结果，而不进行排序 (ls 默认会以档名排序！)
    -F  ：根据文件、目录等资讯，给予附加数据结构，例如：
        *:代表可运行档； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；
    -h  ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；
    -i  ：列出 inode 号码，inode 的意义下一章将会介绍；
    -l  ：长数据串列出，包含文件的属性与权限等等数据；(常用)
    -n  ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在帐号管理提到！)
    -r  ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；
    -R  ：连同子目录内容一起列出来，等於该目录下的所有文件都会显示出来；
    -S  ：以文件容量大小排序，而不是用档名排序；
    -t  ：依时间排序，而不是用档名。
    --color=never  ：不要依据文件特性给予颜色显示；
    --color=always ：显示颜色
    --color=auto   ：让系统自行依据配置来判断是否给予颜色
    --full-time    ：以完整时间模式 (包含年、月、日、时、分) 输出
    --time={atime,ctime} ：输出 access 时间或改变权限属性时间 (ctime) 
                        而非内容变更时间 (modification time)
底下则是一些常用的范例，实际试做看看：

    范例二：承上题，不显示颜色，但在档名末显示出该档名代表的类型(type)
    [root@www ~]# ls -alF --color=never  ~
    total 156
    drwxr-x---  4 root root  4096 Sep 24 00:07 ./
    drwxr-xr-x 23 root root  4096 Sep 22 12:09 ../
    -rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg
    -rw-------  1 root root   955 Sep 24 00:08 .bash_history
    -rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout
    -rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile
    -rw-r--r--  1 root root   176 Jan  6  2007 .bashrc
    drwx------  3 root root  4096 Sep  5 10:37 .gconf/
    -rw-r--r--  1 root root 42304 Sep  4 18:26 install.log
    -rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog
    # 注意看到显示结果的第一行，嘿嘿～知道为何我们会下达类似 ./command 
    # 之类的命令了吧？因为 ./ 代表的是『目前目录下』的意思啊！至於什么是 FIFO/Socket ？
    # 请参考前一章节的介绍啊！另外，那个.bashrc 时间仅写2007，能否知道详细时间？

    范例三：完整的呈现文件的修改时间 *(modification time)
    [root@www ~]# ls -al --full-time  ~
    total 156
    drwxr-x---  4 root root  4096 2008-09-24 00:07:00.000000 +0800 .
    drwxr-xr-x 23 root root  4096 2008-09-22 12:09:32.000000 +0800 ..
    -rw-------  1 root root  1474 2008-09-04 18:27:10.000000 +0800 anaconda-ks.cfg
    -rw-------  1 root root   955 2008-09-24 00:08:14.000000 +0800 .bash_history
    -rw-r--r--  1 root root    24 2007-01-06 17:05:04.000000 +0800 .bash_logout
    -rw-r--r--  1 root root   191 2007-01-06 17:05:04.000000 +0800 .bash_profile
    -rw-r--r--  1 root root   176 2007-01-06 17:05:04.000000 +0800 .bashrc
    drwx------  3 root root  4096 2008-09-05 10:37:49.000000 +0800 .gconf
    -rw-r--r--  1 root root 42304 2008-09-04 18:26:57.000000 +0800 install.log
    -rw-r--r--  1 root root  5661 2008-09-04 18:25:55.000000 +0800 install.log.syslog
    # 请仔细看，上面的『时间』栏位变了喔！变成较为完整的格式。
















